# Валидация сериалайзером входных данных

В этой статье расскажу, как с помощью сериалайзера проверить поступившие данные для записи в БД. Валидация в DRF состоит из множества этапов с массой нюансов. Если при чтении покажется, что деталей очень много и картинка в голове начинает плыть, в конце статьи есть таблица с кратким описанием последовательности всех проверок.

DRF позволяет не только извлекать и передавать записи из БД сторонним приложениям, но и принимать от них данные для использования на вашем веб-сайте. Например, чтобы создать новую запись в БД или обновить существующую. Когда REST API принимает данные извне, происходит их десериализация ― восстановление Python-объекта из последовательности байтов, пришедших по сети.

Процесс создания или обновления одной записи в БД с помощью DRF включает следующие шаги:

1. Объявляем класс сериалайзера, через который будут проходить входные данные. Один и тот же класс сериалайзера может работать одновременно и на запись, и на чтение.
2. Стороннее приложение отправляет POST-, PUT- или PATCH-запрос к эндпоинту API.
3. Контроллер (view), отвечающий за эндпоинт, извлекает [из атрибута _data _объекта _request_](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/requests#data) данные для записи.
4. В контроллере создаём экземпляр сериалайзера, которому передаём поступившие данные, а также при необходимости запись из БД, которую предстоит обновить, и другие аргументы.
5. Вызываем метод _is\_valid_ сериалайзера. Он валидирует данные, а также позволяет скорректировать и расширить их. При валидации используются как инструменты из-под капота, так и наши собственные методы.
6. При успешной валидации вызываем метод _save_ сериалайзера, благодаря которому в БД создаётся новая запись или обновляется существующая.

Одной статьи для подробного разбора, увы, не хватит, поэтому я снова разделил её на две части. В первой части поговорим о создании и работе сериалайзера на запись — это шаги 1, 3 и 5. В следующей статье рассмотрим остальные шаги и проиллюстрируем работу API на примерах.

**Важно:** как и в случае с сериалайзером на чтение, рассмотрим работу сериалайзера на запись на основе класса _serializers.Serializer_. Об особенностях работы дочернего класса _ModelSerializer_ поговорим в [отдельной статье](model\_serializers.md).

### Объявляем класс сериалайзера на запись

Чтобы сериалайзер мог работать на запись, у него должны быть:

* поля, которые могут работать на запись, — поля с атрибутом _read\_only=True_ будут игнорироваться;
* методы _create _(если хотим сохранить в БД новую запись)_ _и _update _(если хотим обновить существующую).

Напомню, что один и тот же класс сериалайзера может работать одновременно и на запись, и на чтение. Можно сделать и разные сериалайзеры под разные запросы.

Попробую пояснить на примере из [документации](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/serializers#proverka-na-urovne-polya):

```
from rest_framework import serializers
class BlogPostSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=100)
    content = serializers.CharField(source='text')
```

Сериалайзер может работать на чтение, преобразовывая каждую переданную из БД запись, у которой есть атрибуты _**title**_ и _**text**_, в словарь _**{'title': 'значение', 'content': 'значение'}**_. Если атрибутов _title_ или _text_ у записи не окажется, возникнет исключение.

Этот же сериалайзер может работать на запись — только нужно дописать методы _**create**_ и _**update**_. Тогда на вход он будет ожидать словарь _**{'title': 'значение', 'content': 'значение'}**_. Если таких ключей в словаре не окажется, по ним будут пустые значения или по ключу _title_ будет строка длиной более 100 символов — снова появится исключение. При штатной отработке вернётся словарь с проверенными данными. Причём один ключ будет _**title**_, а вот второй — _**text**_. На это поведение влияет именованный аргумент _**source**_.

Если такой объём и формат исходящих/входящих данных вас устраивает, можно оставить один класс. Более развёрнутые примеры классов сериалайзера на запись я приведу в следующей статье.

### Создаём экземпляр сериалайзера на запись

При создании в контроллере (view) экземпляра сериалайзера нужно подобрать правильный набор аргументов. Выбор зависит от того, какие запросы будут обрабатываться.

| Аргумент     | «На чтение» — обработка одной записи из БД или их набора для выдачи по GET-запросу                                                                                                                                                                                                                         | «На запись» — создать новую запись в БД по POST-запросу                                                                                                                                                                                                                                                                                                                                 | «На запись» — обновить конкретную запись в БД по PUT- или PATCH-запросу                                                                                                                                                                                              |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **instance** | [Одна](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L493) или [несколько](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L655) записей из БД | Не передаём                                                                                                                                                                                                                                                                                                                                                                             | [Передаём запись](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L199) из БД, которую собираемся обновить                                                                              |
| **data**     | Не передаём                                                                                                                                                                                                                                                                                                | [Словарь](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/serializers.py#L460) с данными, которые хотим валидировать и сохранить в БД. Если _many=True_, то передаём [список](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L624) словарей | Словарь с данными для полного или частичного обновления существующей в БД записи. Если _many=True_, то передаём [список](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L624) словарей |
| **many**     | [Передаём](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L141) со значением True, если из БД извлекаем не одну, а несколько записей                                                                                         | [Передаём](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L141) со значением True, если на вход поступают данные не для одной, а для нескольких будущих записей в БД                                                                                                                                      | [Передаём](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L141) со значением True, если хотим частично или полностью обновить сразу несколько записей в БД                             |
| **partial**  | Не передаём                                                                                                                                                                                                                                                                                                | Не передаём                                                                                                                                                                                                                                                                                                                                                                             | [Передаём](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/fields.py#L501) со значением True для PATCH-запросов                                                                                        |
| **context**  | Через этот аргумент можем [передать любые данные](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/serializers.py#L113), которые нужны сериалайзеру                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                      |

Пример: `serializer = SerializerForUpdateData( instance=current_entry_in_db, data=input_data, partial=True )`

Такие аргументы говорят нам, что экземпляр сериалайзера создан для частичного обновления существующей записи в БД.

**Важно:** входные данные, которые поступили в сериалайзер через аргумент _data_ (то есть сырые, ещё не проверенные данные), доступны в атрибуте _initial\_data_ сериалайзера. К этим данным иногда приходится прибегать при описании логики валидации.

### Валидируем с помощью сериалайзера входные данные

Это ключевая задача сериалайзера при работе на запись, поэтому уделим ей максимальное внимание.

Валидацию запускает метод _is\_valid_. Итог его работы ― два новых атрибута сериалайзера: _validated\_data_ и _errors_.

В каждом атрибуте ― словарь, причём один из них всегда пустой. Если ошибок нет, пусто в _errors_, а если есть ― в _validated\_data_. В первом случае _is\_valid_ возвращает _True_, во втором _False_.

Рассмотрим, из чего состоят пары «ключ–значение» в этих словарях.

| Словарь             | Ключи                                                 | Значения                                                                                                                                                                                                                                                                                                                |
| ------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **validated\_data** | названия полей сериалайзера                           | значения из поступившего в аргументе _data_ словаря по ключам, имя которых [идентично именам полей сериалайзера](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/fields.py#L449), а также дефолтные значения полей сериалайзера (если входных данных нет) |
| **errors**          | название полей сериалайзера либо _non\_field\_errors_ | [расшифровки ошибок](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/serializers.py#L309), которые возникли при валидации полей, либо ошибки, возникшей при валидации вне конкретного поля                                                                |

Примеры:

`{'capital_city': 'London'}`

В поступившем в _data_ словаре по ключу _capital\_city_ есть значение _‘London’_. Оно успешно валидировано через поле _capital\_city_ сериалайзера.

`{'non_field_errors': [ErrorDetail(string='Invalid data. Expected a dictionary, but got str.', code='invalid')]}.`

На вход в аргументе _data_ сериалайзер ожидает словарь, но пришла строка.

`{'non_field_errors': [ErrorDetail(string='The fields country, capital_city must make a unique set.', code='unique')]}.`

Пара значений по ключам _capital\_city_ и _country_ не должны повторять идентичное сочетание значений в таблице в БД.

`{'capital_city': [ErrorDetail(string='This field is required.', code='required')]}.`

В поступившем на вход словаре по ключу _capital\_city_ — пустая строка. Значение не прошло валидацию в поле _capital\_city_ сериалайзера, поскольку поле требует непустых значений.

Совпадение имён ключей в словаре, который поступает в сериалайзер, с именами полей сериалайзера ― принципиальная вещь. Если будут нестыковки, велика вероятность получить ошибку сразу или чуть позже, когда выяснится, что для записи в БД не хватает части данных, которые были на входе в сериалайзер.

У метода _is\_valid_ есть один аргумент ― [_raise\_exception_](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/serializers.py#L715). Если у него значение _False_, которое задано по умолчанию, метод [не будет выбрасывать _ValidationError_](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/serializers.py#L227). Даже если будут ошибки, метод отработает до конца, вернёт _False_, а информация об ошибках будет доступна в атрибуте _errors_. На ошибки любых иных типов настройка _raise\_exception_ не влияет.

### Как происходит валидация после запуска is\_valid

Валидация носит многоступенчатый характер и условно её можно разделить на три этапа:

1. Проверка, есть ли что валидировать.
2. Проверки поступивших данных на уровне полей сериалайзера.
3. Проверки на метауровне, когда можно проверить поступившие данные не для конкретного поля, а целиком.

**Важно:** ниже описывается процесс валидации данных, которые предназначены для одной записи в БД. Как и в случае с сериалайзером на чтение, на запись можно выставить _many=True_ и принимать набор данных. Тогда появится ещё одна ступень проверки ― на входе будет ожидаться список словарей, а не один словарь. Далее по этому списку запускается цикл, и каждый отдельный словарь с данными будет проверяться так же, как описано ниже.

#### Этап 1. Есть ли что валидировать

DRF [проверяет](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L213), есть ли у сериалайзера атрибут _initial\_data_. Этот атрибут создаётся, если при создании сериалайзера [был передан](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L110) аргумент _data_. Если его нет, то будет выброшено исключение _AssertionError_.

Далее идёт проверка содержимого и формата _data_.

Если в _data_ ничего не оказалось (_None_), то [возможны два исхода](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L543):

* _ValidationError_;
* окончание валидации с возвратом _None_ в _validated\_data_, если при создании сериалайзера передавали аргумент _allow\_null_ со значением _True_.

Если _data_ всё же что-то содержит, DRF проверяет тип поступивших данных — они должны быть [словарём](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L460).

#### Этап 2. Проверки на уровне полей

Важнейшие тезисы:

* если для конкретного ключа из поступившего словаря нет одноимённого writable-поля сериалайзера, пара «ключ–значение» останется за бортом валидации;
* если для конкретного writable-поля сериалайзера не окажется одноимённого ключа в поступившем словаре или ключ будет, но его значение _None_, может быть несколько вариантов развития событий. Либо поднимется исключение, либо продолжится валидация значения поля, либо поле будет проигнорировано;
* проверку, уже встроенную в класс конкретного поля, можно усилить валидаторами, а также описав собственный метод _validate\_названиеПоля_;
* проверки идут последовательно по всем полям, и только после этого запускается следующий этап ― проверки на метауровне.

В методе _to\_internal\_value_ сериалайзер собирает в генератор все поля, которые [могут работать на запись](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L470), то есть те поля, у которых нет _read\_only=Truе_. Затем сериалайзер [перебирает каждое поле в цикле](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L472).

| Проверка                                                                     | Действие                                                                                                                                                                                                                                                                                                                                        | Результат                                                                                                                                                                                                                          |
| ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Есть ли у поля кастомный метод валидации?                                    | <p>Для каждого поля внутри класса сериалайзера можно описать проверку значения с любой нужной логикой. Название метода должно быть в формате <em>validate_НазваниеПоля</em>.<br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/serializers.py#L473">Исходный код</a></p> | Если метод есть, он будет задействован позднее.                                                                                                                                                                                    |
| Есть ли в поступившем словаре ключ с тем же именем, что и поле сериалайзера? | <p>Задача ― извлечь значение для дальнейшей валидации.<br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L427">Исходный код</a></p>                                                                                                                            | Если ключ найден, для дальнейшей валидации берётся его значение, если не найден ― значение [_empty_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L44). |

#### Этап 2.1. Валидирование отсутствующих значений для поля

Если для поля не нашлось одноимённого ключа в поступившем словаре, срабатывает [метод _validate\_empty\_values_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L522) класса _fields.Field_ и [проверяет](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L536) допустимость значения _empty_.

_empty_ ― это просто пустой класс. DRF передаёт его в качестве значения полям, для которых не нашлось значений во входных данных. Он помечает эти поля как пустые и валидирует определённым образом. Как поясняют разработчики DRF, необходимость в _empty_ вызвана тем, что _None_ вполне может быть валидным значением.

| Поле обязательно для заполнения _(required=True)_ | Сериалайзер допускает частичное обновление _(partial=True)_ | У поля есть дефолтное значение _(default=...)_                                                                                                                                                       | Результат                                                                                                                                                                                                                                                                                                                                                                      |
| ------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| +                                                 | Не имеет значения                                           | <p>–<br>(<a href="https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest_framework/fields.py#L304">и не может быть</a>, если <em>required=True</em>)</p> | _ValidationError_                                                                                                                                                                                                                                                                                                                                                              |
| –                                                 | Не имеет значения                                           | –                                                                                                                                                                                                    | [Поднимается](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L538) исключение _SkipField_, поле дальше [**не** валидируется](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L483) и **не** попадает в _validated\_data_ |
| –                                                 | +                                                           | +                                                                                                                                                                                                    | Поле дальше **не** валидируется и **не** попадает в _validated\_data_                                                                                                                                                                                                                                                                                                          |
| –                                                 | –                                                           | +                                                                                                                                                                                                    | Поле **валидируется** дальше и вместе с дефолтным значением **попадает** в _validated\_data_                                                                                                                                                                                                                                                                                   |

**Примечание:** результат, попадает или не попадает поле в _validated\_data_, указан с условием того, что остальные поля успешно прошли валидацию. Если хотя бы одно поле провалит проверку, словарь _validated\_data_ всегда будет пустым.

**Если в поле значение **_**None**_, работает [метод _validate\_empty\_values_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L522) класса _fields.Field_.

В этом случае [проверяется](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L543), есть ли у поля атрибут _allow\_null_ в значении _True_. Если его нет, появится _ValidationError_. Если _allow\_null=True_, дальнейшая валидация внутри поля прекратится. Если значение _None_ пройдёт проверку вне поля (метавалидаторами), то это значение и войдёт в _validated\_data_.

После проверок на _empty_ и _None_ запускаются проверочные механизмы внутри конкретного поля.

#### Этап 2.2. Проверка в поле методом to\_internal\_value

**Важно:** если значение _empty_ или _None_, проверка [не проводится](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L566).

У каждого поля DRF, которое может работать на запись, есть метод _to\_internal\_value_. Чтобы понять логику этого метода, нужно заглянуть под капот в класс соответствующего поля.

Приведу [пример](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L801) ― _to\_internal\_value_ поля класса _CharField_.

```
def to_internal_value(self, data):
    if isinstance(data, bool) or not isinstance(data, (str, int, float,)):
        self.fail('invalid') value = str(data)
    return value.strip() if self.trim_whitespace else value
```

Проверка выдаст ошибку, если на вход не поступила строка или число. Также не допускаются логические типы _True_ и _False_. Проверку на наличие последних разработчики выделили отдельно, т. к. класс _bool_ наследует от класса _int_.

Если вы собираетесь использовать кастомный класс поля для валидации входных данных, проследите, чтобы там был метод _to\_internal\_value_, иначе DRF [укажет на ошибку](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L610).

#### Этап 2.3. Проверка поля валидаторами

**Важно:** проверка [не проводится](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L566), если значение _empty_ или _None_.

При объявлении поля сериалайзера среди аргументов можно указать:

* встроенные [джанго-валидаторы](https://www.djbook.ru/rel3.0/ref/validators.html#built-in-validators) (например, проверку максимальной длины строки, минимально допустимого числового значения);
* встроенные [DRF-валидаторы](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/validators#uniquevalidator);
* [собственные валидаторы](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/validators#napisanie-polzovatelskikh-validatorov) в виде функции или класса.

Валидаторы передаются списком в аргументе _validators_ при описании поля сериалайзера, даже если валидатор всего один. Некоторые валидаторы можно передать через специально предусмотренные атрибуты конкретного поля. Например, у поля сериалайзера _IntegerField_ есть аргумент [_max\_value_](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/fields#integerfield), который создаёт джанго-валидатор _MaxValueValidator_. Поэтому оба варианта будут верны, но в первом случае нужно ещё сделать импорт из _django.core.validators_:

`capital_population = serializers.IntegerField( validators=[MaxValueValidator(1000000)] )`

`capital_population = serializers.IntegerField( max_value=1000000 )`

Также отмечу, что некоторые поля могут наделяться валидаторами из-под капота без необходимости объявлять их явно. Например, в поле _CharField_ уже заложены два валидатора, названия которых говорят сами за себя: джанго-валидатор [_ProhibitNullCharactersValidator_](https://www.djbook.ru/rel3.0/ref/validators.html#prohibitnullcharactersvalidator) и DRF-валидатор [_ProhibitSurrogateCharactersValidator_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/validators.py#L170).

#### Этап 2.4. Проверка кастомным методом validate\_названиеПоля

Этот метод **не** обязателен, и мы его описываем, когда нужно дополнительно проверить значение, уже отвалидированное внутри поля описанными выше инструментами.

Логику задаём любую. Результат работы метода ― возврат значения или ошибки. Скелет метода можно представить так:

```
def validate_НазваниеПоляСериалайзера(self, value):
    if условия_при_которых_значение_невалидно:
        raise serializers.ValidationError("Описание ошибки")
    return value
```

Обратите внимание на _self_ — за ним стоит экземпляр сериалайзера. Через него есть доступ к различной ценной информации, которая может пригодиться при валидации. Например, через _self.initial\_data _можно получить доступ ко всему словарю с входными данными до начала их валидации.

И ещё один момент, который следует держать в голове при описании логики метода: если допускается, что поле будет пустым, и есть дефолтное значение, а также если в поле можно передавать _None_, эти значения также будут поступать в рассматриваемый метод.

#### Этап 2.5. Присвоение имени ключу с успешно валидированным в поле значением

В случае успеха метод _to\_internal\_value_ сериалайзера возвращает словарь с проверенными данными. По умолчанию именем ключа становится имя поля сериалайзера. Но это поведение можно переопределить благодаря атрибуту _source_, о котором мы подробно говорили [в статьях о работе сериалайзера на чтение](https://habr.com/ru/company/yandex\_praktikum/blog/562050/).

Если у поля есть атрибут _source_, то именем ключа станет не имя соответствующего поля, а значение из атрибута _source_. Такая логика описана в функции [_set\_values_](https://github.com/encode/django-rest-framework/blob/e92016ac2e926483e05e296558fc3d1ea3279625/rest\_framework/fields.py#L112) модуля _restframework.fields_. Эта функция [вызывается в конце работы](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L486) _to\_internal\_value_ и получает в качестве аргумента keys атрибут _source\_attrs_ поля (мы подробно разбирали его в [предыдущей статье](https://habr.com/ru/company/yandex\_praktikum/blog/562050/)).

Обратимся к примеру.

`content = serializers.CharField(source='text')`

Если это поле используется при работе на запись, то сериалайзер будет искать во входных данных ключ _content_ и валидировать значение по этому ключу методом _to\_internal\_value_. В случае успеха он вернёт ― **внимание!** ― валидированное значение уже с ключом _'text'._ Получится _'text': 'валидированное значение, которое пришло с ключом content'_. Именно в таком виде пара «ключ–значение» попадут в _validated\_data_, но только если пройдут следующий этап ― проверку метавалидаторами.

#### Этап 3. Проверка на уровне всего сериалайзера

Этап разбивается на две части.

**Этап 3.1. Проверка метавалидаторами** Эти валидаторы не привязаны к конкретному полю и получают на вход весь набор данных, которые прошли проверку в полях.

Чтобы задать метавалидатор, нужно прописать внутри класса нашего сериалайзера класс _Meta_ с атрибутом _validators_. Как и валидаторы на уровне полей, метавалидаторы [указывают списком](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L380), даже если валидатор один.

Пример метавалидатора из коробки ― [_UniqueTogetherValidator_](https://ilyachch.gitbook.io/django-rest-framework-russian-documentation/overview/navigaciya-po-api/validators#uniquetogethervalidator). Он проверяет, уникально ли сочетание значений из нескольких полей по сравнению с тем, что уже есть в БД.

**Этап 3.2. Проверка методом validate** Последний рубеж валидации так же, как и метавалидаторы, опционален. Заготовка метода _validate_ уже находится [под капотом](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L519) родительского класса сериалайзера.

```
def validate(self, attrs):
    return attrs
```

Если в нём есть необходимость, достаточно переопределить метод.

Метод _validate_, как и метавалидаторы, на вход принимает весь набор валидированных данных и позволяет сверить их между собой и с данными в БД в одном месте.

### Для закрепления: таблица с последовательностью валидирования входных данных в DRF

| Этап | Что проверяется                                              | Метод                                                                                                                                                                                                                                                                                                                                                               | Примечание                                  |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| 1    | Передан ли аргумент _data_ при создании сериалайзера         | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/serializers.py#L212"><em>serializers.BaseSerializer.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/serializers.py#L212"><em>is_valid</em></a></p>      | —                                           |
| 2    | Если в _data_ сериалайзеру передано _None_, допустимо ли это | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L543"><em>fields.Field.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L543"><em>validate_empty_values</em></a></p>                 | Если передано _Non_e, валидация завершается |
| 3    | Передан ли в _data_ словарь                                  | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/serializers.py#L460"><em>serializers.Serializer.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/serializers.py#L460"><em>to_internal_value</em></a></p> | —                                           |

Метод [_serializers.Serializer.to\_internal\_value_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/serializers.py#L472) запускает цикл по всем writable-полям со следующими проверками по каждому полю:

| Этап | Что проверяется                                                          | Метод                                                                                                                                                                                                                                                                                                                                               | Примечание                                                                                                                                                 |
| ---- | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 4    | Есть ли в _data_ ключ с таким же именем, что и поле сериалайзера         | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L449"><em>fields.Field.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L449"><em>get_value</em></a></p>             | Если ключа нет или по нему нет значения и это допустимо, значением поля становится класс _empty_                                                           |
| 5    | Если значение поля _empty_, есть ли у поля дефолтное значение            | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L492"><em>fields.Field.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L492"><em>get_default</em></a></p>           | Если дефолтного значения нет, поле исключается из валидации. В _validated\_data_ оно никак не будет представлено                                           |
| 6    | Если значение из входных данных _None_, допускает ли поле это            | <p><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L543"><em>fields.Field.</em></a><br><a href="https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest_framework/fields.py#L543"><em>validate_empty_values</em></a></p> | Допустимость определяется значением атрибута _allow\_null_ поля                                                                                            |
| 7    | Соответствует ли значение внутренним требованиям поля                    | <p><em>fields.Field.</em><br><em>классКонкретногоПоля.</em><br><em>to_internal_value</em></p>                                                                                                                                                                                                                                                       | Проверка не проводится, если значение _empty_ или _None_                                                                                                   |
| 8    | Проходят ли значение валидаторы, которые встроены в поле или приданы ему | [_fields.Field.run\_validators_](https://github.com/encode/django-rest-framework/blob/24a938abaadd98b5482bec33defd285625842342/rest\_framework/fields.py#L572)                                                                                                                                                                                      | <p>Не предусмотренные изначально валидаторы нужно установить самостоятельно.<br>Проверка не проводится, если значение <em>empty</em> или <em>None</em></p> |
| 9    | Проходит ли значение поля проверку кастомным методом валидации           | метод _validate\_НазваниеПоля класса сериалайзера_                                                                                                                                                                                                                                                                                                  | Логику метода нужно описать самостоятельно                                                                                                                 |

Потом следуют метапроверки, которые можно запустить после окончания цикла проверки каждого поля.

| Этап | Что проверяется                                                               | Метод                                           | Примечание                                              |
| ---- | ----------------------------------------------------------------------------- | ----------------------------------------------- | ------------------------------------------------------- |
| 10   | Проходят ли значения полей метавалидаторы                                     | атрибут _validators_ класса _Meta_ сериалайзера | Для проверки валидаторы нужно задать самостоятельно     |
| 11   | Проходят ли все значения полей вместе проверку кастомным методом сериалайзера | метод _validate_ сериалайзера                   | Для проверки логику метода нужно описать самостоятельно |

При работе с _ModelSerializer_ валидаторы из модели могут автоматически переноситься в сериалайзер, поэтому вручную их можно не указывать. Об этом мы поговорим в отдельной статье о _ModelSerializer_.

***
